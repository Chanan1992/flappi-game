<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=portrait"
    />
    <title>FlapPi</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <script src="https://sdk.minepi.com/pi-sdk.js"></script>
    <script src="piAuth.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #222;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      #leaderboard {
        position: absolute;
        top: 20px;
        right: 20px;
        color: #fff;
        font-family: Arial;
        font-size: 14px;
        max-width: 200px;
        word-wrap: break-word;
      }
    </style>
  </head>

  <body>
    <script>
      class BaseScene extends Phaser.Scene {
        constructor(key) {
          super(key);
        }
      }

      class MenuScene extends BaseScene {
        constructor() {
          super({ key: "MenuScene" });
        }

        preload() {
          this.load.image("rocket", "assets/pi_rocket.png");
          this.load.image("space", "assets/back.png");
        }

        async create() {
          // Login gebruiker (alleen de eerste keer wordt echt gevraagd)

          this.background;

          // Achtergrond
          this.background = this.add
            .image(0, 0, "space")
            .setOrigin(0)
            .setDisplaySize(
              this.scale.gameSize.width,
              this.scale.gameSize.height
            )
            .setScrollFactor(0);

          await initPiAuth();
          const user = getPiUser();

          this.add.text(100, 100, `Welkom ${user?.username || "Gast"}`, {
            fontSize: "32px",
            fill: "#fff",
          });

          this.add
            .image(this.scale.width / 2, this.scale.height / 4, "rocket")
            .setScale(0.14);
          this.add
            .text(this.scale.width / 2, this.scale.height / 3, "FlapPi", {
              fontSize: "48px",
              fill: "#fff",
            })
            .setOrigin(0.5);

          const startButton = this.add
            .text(this.scale.width / 2, this.scale.height / 2, "Start Game", {
              fontSize: "32px",
              fill: "#ffffff",
              backgroundColor: "#6A0DAD", // Pi purple
              padding: { x: 20, y: 10 },
            })
            .setOrigin(0.5)
            .setInteractive();

          startButton.on("pointerdown", () => {
            this.scene.start("GameScene", {
              retryUsed: false,
              continueScore: 0,
            });
          });

          this.time.addEvent({
            delay: 3000, // Elke 3 seconden
            callback: () => this.spawnFlyingRocket(),
            callbackScope: this,
            loop: true,
          });

          // Donate button
          const donateButton = this.add
            .text(this.scale.width - 100, 20, "More games?\nDonate 1 Pi", {
              fontSize: "18px",
              fill: "#fff",
              backgroundColor: "#6A0DAD", // Pi purple
              padding: { x: 10, y: 5 },
              align: "center",
            })
            .setOrigin(0.5, 0)
            .setInteractive();

          donateButton.on("pointerdown", () => {
            // Placeholder for future Pi donation
            // if (checkPiBalance(1)) {
            //     deductPi(1);
            //     alert('Thank you for your 1 Pi donation! More features coming soon!');
            // } else {
            //     alert('Not enough Pi to donate!');
            // }
            alert(
              "Thank you! Donation of 1 Pi would support more game features. (Not implemented yet)"
            );
          });

          const leaderboardButton = this.add
            .text(
              this.scale.width / 2,
              this.scale.height / 1.75,
              "Leaderboard",
              {
                fontSize: "32px",
                fill: "#ffffff",
                backgroundColor: "#6A0DAD", // Pi purple
                padding: { x: 20, y: 10 },
              }
            )
            .setOrigin(0.5)
            .setInteractive();

          leaderboardButton.on("pointerdown", () => {
            this.scene.start("LeaderboardScene");
          });
        }

        spawnFlyingRocket() {
          const beginY = Phaser.Math.Between(50, 550);
          const endY = Phaser.Math.Between(50, 550);
          const dx = 1100; // 1000 - (-100)
          const dy = endY - beginY;
          const angleRad = Math.atan2(dy, dx);

          const rocket = this.add
            .image(-100, beginY, "rocket")
            .setScale(0.14) // Grotere raket
            .setDepth(1)
            .setRotation(angleRad);

          this.tweens.add({
            targets: rocket,
            x: 1000,
            y: endY,
            duration: Phaser.Math.Between(6000, 10000),
            onComplete: () => rocket.destroy(),
          });
        }
      }

      class LeaderboardScene extends Phaser.Scene {
        constructor() {
          super({ key: "LeaderboardScene" });
        }

        preload() {
          // Als je een achtergrond hebt
          this.load.image("space", "assets/back.png");
        }

        async create() {
          // Achtergrond
          this.add
            .image(0, 0, "space")
            .setOrigin(0)
            .setDisplaySize(this.scale.width, this.scale.height);

          this.add
            .text(this.scale.width / 2, 50, "üèÜ Leaderboard", {
              fontSize: "42px",
              fill: "#fff",
            })
            .setOrigin(0.5);

          // container voor scores
          this.scrollContainer = this.add.container(50, 180);

          // scrollmask instellen
          const maskShape = this.make.graphics();
          maskShape.fillStyle(0xffffff);
          maskShape.fillRect(
            50,
            180,
            this.scale.width - 100,
            this.scale.height - 320
          );
          const mask = maskShape.createGeometryMask();
          this.scrollContainer.setMask(mask);

          // scroll variabelen
          this.scrollY = 0;
          this.input.on("wheel", (pointer, gameObjects, deltaX, deltaY) => {
            this.scrollY -= deltaY * 0.5;
            this.scrollY = Phaser.Math.Clamp(this.scrollY, -this.maxScroll, 0);
            this.scrollContainer.y = 180 + this.scrollY;
          });

          // Scrollen met muiswiel
          this.input.on("wheel", (pointer, gameObjects, dx, dy) => {
            this.scrollContent(dy);
          });

          // Scrollen met touch drag (voor mobiel)
          this.input.on("pointerdown", (pointer) => {
            this.startY = pointer.y;
            this.startContentY = this.scrollY;
          });

          this.input.on("pointermove", (pointer) => {
            if (pointer.isDown) {
              const deltaY = pointer.y - this.startY;
              this.scrollContent(-deltaY, this.startContentY);
            }
          });

          // Terugknop naar Menu
          const backButton = this.add
            .text(this.scale.width / 2, this.scale.height - 80, "‚¨Ö Terug", {
              fontSize: "32px",
              fill: "#ffffff",
              backgroundColor: "#6A0DAD", // Pi purple
              padding: { x: 20, y: 10 },
            })
            .setOrigin(0.5)
            .setInteractive();

          backButton.on("pointerdown", () => {
            this.scene.start("MenuScene");
          });

          // laad scores
          this.loadScores();
        }

        async loadScores() {
          try {
            const response = await fetch("/api/score/leaderboard");
            const scores = await response.json();

            const currentUser = "A"; // <-- straks uit Pi login
            const playerScore = scores.find((s) => s.player === currentUser);

            // Toon speler score altijd bovenaan
            if (playerScore) {
              const playerItem = this.add
                .text(
                  this.scale.width / 2,
                  120,
                  `Your personal highscore: ${playerScore.score}`,
                  {
                    fontSize: "24px",
                    fill: "#ffd700",
                    backgroundColor: "#333",
                    padding: { x: 12, y: 8 },
                  }
                )
                .setOrigin(0.5);
              playerItem.setStroke("#000", 4);
            }

            // Lijst renderen
            let y = 0;
            scores.forEach((score, index) => {
              const item = this.add
                .text(
                  this.scale.width / 4,
                  y,
                  `${index + 1}. ${score.player} - ${score.score}`,
                  {
                    fontSize: "24px",
                    fill: score.player === currentUser ? "#ffd700" : "#fff",
                  }
                )
                .setOrigin(0, 0);

              if (score.player === currentUser) {
                item.setFontStyle("bold");
              }

              this.scrollContainer.add(item);
              y += 40;
            });

            this.maxScroll = Math.max(0, y - (this.scale.height - 320));
          } catch (err) {
            console.error("Kon scores niet laden:", err);

            this.add
              .text(
                this.scale.width / 2,
                200,
                "Fout bij laden van leaderboard",
                { fontSize: "24px", fill: "#f00" }
              )
              .setOrigin(0.5);
          }
        }

        async fetchLeaderboard() {
          try {
            const res = await fetch("/api/score/leaderboard");
            return await res.json();
          } catch (err) {
            console.error("Failed to fetch leaderboard", err);
            return [];
          }
        }

        scrollContent(dy, baseY = this.scrollY) {
          this.scrollY = Phaser.Math.Clamp(baseY - dy, -this.maxScroll, 0);
          this.scrollContainer.y = 180 + this.scrollY;
        }
      }

      class GameScene extends BaseScene {
        constructor() {
          super({ key: "GameScene" });
        }

        init(data) {
          this.retryUsed = data?.retryUsed || false;
          this.continueScore = data?.continueScore || 0;
        }

        preload() {
          // Placeholder assets (vervang met echte afbeeldingen voor productie)
          this.load.image("rocket", "assets/pi_rocket.png");
          this.load.image("pipeTop", "assets/pipe_top_long.png");
          this.load.image("pipeBottom", "assets/pipe_bottom_long.png");
          this.load.image("smoke", "assets/flamesss.png");
          this.load.image("space", "assets/back.png");
          this.load.audio("flapSound", "assets/flap.mp3");
          this.load.audio("scoreSound", "assets/score.mp3");
          this.load.audio("explosionSound", "assets/explosion.mp3");
        }

        create(data) {
          this.pipes = []; // Array to manage pipes

          this.score = data?.continueScore || 0; // if retry, start with old score
          this.scoreText;

          this.retryUsed = data.retryUsed || false;
          this.isGameOver = false;

          this.background;
          // this.highScoreData = this.loadHighScore();
          // this.highScoreText;
          this.retryButton;
          this.spawnTimer = 0;
          this.spawnInterval = 2000;
          this.moveSpeed = this.scale.width * 0.25; // Corrected casing and initialization

          this.matter.world.setBounds(
            undefined,
            undefined,
            undefined,
            undefined,
            {
              left: true,
              right: true,
              top: false,
              bottom: false,
            }
          );

          // Achtergrond
          this.background = this.add
            .tileSprite(0, 0, this.scale.width, this.scale.height, "space")
            .setOrigin(0)
            .setDisplaySize(this.scale.width, this.scale.height)
            .setScrollFactor(0);

          const { width, height } = this.textures
            .get("rocket")
            .getSourceImage();

          this.rocket = this.matter.add
            .sprite(64, 64, "rocket", null, {
              shape: {
                type: "fromVertices",
                verts: [
                  { x: (-width / 2) * 0.9, y: -height / 2.5 }, // Neus linksboven
                  { x: (width / 2) * 0.4, y: -height / 5 }, // Neus rechtsboven
                  { x: (width / 2) * 0.75, y: 0 }, // Rechtervin boven
                  { x: (width / 2) * 0.4, y: height / 5 }, // Onderkant rechts
                  { x: (-width / 2) * 0.9, y: height / 2.5 }, // Onderkant links
                  { x: (-width / 2) * 0.6, y: 0 }, // Linkervin boven
                ],
                flagInternal: true,
              },
              frictionAir: 0.05,
              friction: 1.0,
              restitution: 0.1,
            })
            .setScale(0.14)
            .setOrigin(0.5);

          this.rocket.setFrictionAir(0.02); // Voeg wat luchtweerstand toe voor natuurlijke rotatie
          this.rocket.setBounce(0.2); // Kleine bounce bij collisie

          // Rookeffect emitter
          this.particles = this.add.particles("smoke");
          this.emitter = this.particles.createEmitter({
            speed: 1,
            lifespan: 500,
            scale: { start: 0.05, end: 0 },
            alpha: { start: 0.8, end: 0 },
            blendMode: "ADD",
            quantity: 2,
            on: false,
          });
          this.emitter.startFollow(this.rocket, -25, 0); // Rook komt uit de achterkant van de raket

          // Score tekst
          this.scoreText = this.add
            .text(16, 48, "Score: " + this.score, {
              fontSize: "32px",
              fill: "#FFFFFF",
            })
            .setDepth(10);
          this.highScoreText = this.add
            .text(
              16,
              16,
              "High Score: " + getPlayerHighscore(PiUser.username),
              {
                fontSize: "32px",
                fill: "#FFFFFF",
              }
            )
            .setDepth(10);

          // Input handling
          this.input.on("pointerdown", this.flap, this);
          this.input.keyboard.on("keydown-SPACE", this.flap, this);

          // Collisie detectie
          this.matter.world.on("collisionstart", (event, bodyA, bodyB) => {
            if (
              (bodyA.gameObject === this.rocket ||
                bodyB.gameObject === this.rocket) &&
              (bodyA.gameObject instanceof Phaser.GameObjects.Image ||
                bodyB.gameObject instanceof Phaser.GameObjects.Image)
            ) {
              this.gameOver();
            }
          });

          this.flapSound = this.sound.add("flapSound");
          this.scoreSound = this.sound.add("scoreSound", { volume: 0.5 });
          this.explosionSound = this.sound.add("explosionSound");

          // Set a fixed time step for Matter.js to ensure consistency
          this.matter.world.engine.timing.timeScale = 1; // Default time scale
        }

        async getPlayerHighscore(username) {
          try {
            const res = await fetch(`/api/score/${username}`);
            if (!res.ok) throw new Error("Failed to fetch highscore");
            const data = await res.json();
            return data?.score || 0;
          } catch (err) {
            console.error("‚ùå Kon highscore niet ophalen:", err);
            return 0;
          }
        }

        // Simpele MD5 implementatie (voor demo, gebruik een library zoals md5.js in productie)
        md5(str) {
          // Dit is een placeholder, vervang door een echte MD5 library in productie
          let hash = 0;
          for (let i = 0; i < str.length; i++) {
            hash = (hash << 5) - hash + str.charCodeAt(i);
            hash |= 0; // Convert to 32-bit integer
          }
          return hash.toString(16);
        }

        update(time, delta) {
          if (this.isGameOver) return; // Normalize delta to a standard value (e.g., 16.67ms for 60 FPS)

          const fixedDelta = Math.min(delta, 16.67); // Cap delta to prevent large steps
          this.matter.world.step(fixedDelta);

          // Check boundaries using physics body position
          if (
            this.rocket.body.position.y > this.game.canvas.height ||
            this.rocket.body.position.y < 0
          ) {
            this.gameOver();
          }

          // Rotation based on velocity
          let rotation = Phaser.Math.RadToDeg(
            this.rocket.body.velocity.y * 0.1
          );
          rotation = Phaser.Math.Clamp(rotation, -45, 90);
          this.rocket.setRotation(Phaser.Math.DegToRad(rotation));

          // Background scroll
          if (this.moveSpeed) {
            // Safety check
            this.background.tilePositionX +=
              this.moveSpeed * (fixedDelta / 1000);
          }

          // Pipes movement
          this.pipes.forEach((pipe) => {
            if (this.moveSpeed) {
              // Safety check
              pipe.x -= this.moveSpeed * (fixedDelta / 1000);
            }
            if (
              !pipe.scored &&
              pipe.isTopPipe &&
              pipe.x < this.rocket.x - pipe.displayWidth / 2
            ) {
              pipe.scored = true;
              this.score += 1;
              this.scoreText.setText("Score: " + this.score);
              this.scoreSound.play();
            }

            if (pipe.body.position.x < -pipe.displayWidth) {
              pipe.destroy();
              this.pipes = this.pipes.filter((p) => p !== pipe);
            }
          });

          // Pipes spawning
          this.spawnTimer += fixedDelta;
          if (this.spawnTimer >= this.spawnInterval) {
            this.addPipe();
            this.spawnTimer -= this.spawnInterval;
          }
        }

        flap() {
          if (!this.isGameOver) {
            this.rocket.setVelocityY(-5.5);
            this.rocket.setRotation(Phaser.Math.DegToRad(-45)); // Roteer omhoog bij flap
            // Activeer rookeffect en pas rotatie aan
            this.particles.emitters.list[0].setAngle({
              min: this.rocket.angle - 20,
              max: this.rocket.angle + 20,
            });
            this.particles.emitters.list[0].explode();

            this.flapSound.play();
          }
        }

        addPipe() {
          if (this.isGameOver) return;

          const gameHeight = this.game.canvas.height;
          const gameWidth = this.game.canvas.width;

          const gap = 240;
          const minY = -100;
          const maxY = (gameHeight - gap) / 2 - 250;
          const pipeY = Phaser.Math.Between(minY, maxY);

          const topPipeY = pipeY;
          const bottomPipeY = pipeY + gap;

          this.matter.world.setBounds(
            undefined,
            undefined,
            undefined,
            undefined,
            {
              left: true,
              right: true,
              top: false,
              bottom: false,
            }
          );

          const topPipe = this.matter.add
            .image(gameWidth, pipeY, "pipeTop")
            .setOrigin(0.5, 0.5)
            .setDisplaySize(167 / 2, 1303 / 2)
            .setIgnoreGravity(true);
          topPipe.body.ignoreWorldBounds = true;
          topPipe.scored = false;
          topPipe.isTopPipe = true;
          this.pipes.push(topPipe);

          const bottomPipe = this.matter.add
            .image(gameWidth, bottomPipeY + 1303 / 3.33 + gap, "pipeBottom")
            .setOrigin(0.5, 0.5)
            .setDisplaySize(167 / 2, 1303 / 2)
            .setIgnoreGravity(true);
          bottomPipe.scored = false;
          bottomPipe.body.ignoreWorldBounds = true;
          this.pipes.push(bottomPipe);
        }

        gameOver() {
          // if (!isGameOver) {
          this.isGameOver = true;
          this.explosionSound.play();
          this.matter.pause();
          this.rocket.setTint(0xff0000);
          this.add
            .text(
              this.scale.width / 2,
              this.scale.height / 2 - 80,
              "Game Over",
              {
                fontSize: "64px",
                fill: "#FFFFFF",
              }
            )
            .setOrigin(0.5);

          if (this.score > getPlayerHighscore(PiUser.username)) {
            this.postScore(this.score);
          }

          if (!this.retryUsed) {
            // Show retry explanation
            this.add
              .text(
                this.scale.width / 2,
                this.scale.height / 2,
                "Retry for 0.1 Pi and keep your current score and streak!",
                { fontSize: "16px", fill: "#fff", align: "center" }
              )
              .setOrigin(0.5);

            // Retry button
            const retryButton = this.add
              .text(
                this.scale.width / 2,
                this.scale.height / 2 + 80,
                "Buy retry",
                {
                  fontSize: "28px",
                  fill: "#fff",
                  backgroundColor: "#6A0DAD", // Pi purple
                  padding: { x: 20, y: 10 },
                }
              )
              .setOrigin(0.5)
              .setInteractive();

            retryButton.on("pointerdown", () => {
              // In the future, add Pi payment logic here
              this.scene.restart({
                continueScore: this.score,
                retryUsed: true,
              });
              this.isGameOver = false;
              this.pipes = [];
            });
          }

          // Main menu button
          const mainMenuButton = this.add
            .text(
              this.scale.width / 2,
              this.scale.height / 2 + 180,
              "Back to main menu",
              {
                fontSize: "28px",
                fill: "#fff",
                backgroundColor: "#6A0DAD", // Pi purple
                padding: { x: 20, y: 10 },
              }
            )
            .setOrigin(0.5)
            .setInteractive();

          mainMenuButton.on("pointerdown", () => {
            this.scene.start("MenuScene");
          });
        }

        async postScore(score) {
          if (!window.PiUser) {
            console.warn("Niet ingelogd, score niet opgeslagen.");
            return;
          }

          try {
            await fetch("/api/score", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                player: PiUser.username, // hier kun je later Pi-username gebruiken
                score: score,
              }),
            });
          } catch (err) {
            console.error("Fout bij posten score:", err);
          }
        }
      }

      const config = {
        type: Phaser.AUTO,
        fps: {
          target: 60,
          forceSetTimeOut: true,
        },
        physics: {
          default: "matter", // Switch to Matter.js
          matter: {
            gravity: { y: 0.3 }, // Increased to 0.3 for faster fall
            debug: false, // Show hitbox for debugging
          },
        },
        scale: {
          mode: Phaser.Scale.FIT,
          width: 640,
          height: 960,
        },
        scene: [MenuScene, LeaderboardScene, GameScene],
      };

      new Phaser.Game(config);

      // Simpele geheime sleutel voor checksum (moet consistent blijven)
      SECRET_KEY = "flappyPi2025";

      MOVE_SPEED = 200; // Pixels per second
    </script>
  </body>
</html>
